; Compute the minimum (min) or maximum (max) of two integers without branching

(declare-const in_x (_ BitVec 32))
(declare-const in_y (_ BitVec 32))

(define-fun spec_min ((x (_ BitVec 32)) (y (_ BitVec 32))) (_ BitVec 32)
    (ite (bvslt x y) x y)
)

(define-fun spec_max ((x (_ BitVec 32)) (y (_ BitVec 32))) (_ BitVec 32)
    (ite (bvsgt x y) x y)
)

; r = y ^ ((x ^ y) & -(x < y)); // min(x, y)
(define-fun impl0_min ((x (_ BitVec 32)) (y (_ BitVec 32))) (_ BitVec 32)
    (bvxor y (bvand (bvxor x y) (bvneg (ite (bvslt x y) (_ bv1 32) (_ bv0 32)))))
)

(push 1)
(echo "spec_min != impl0_min")
(assert (not (= (spec_min in_x in_y) (impl0_min in_x in_y))))
(check-sat)
(echo "")
(pop 1)

; r = x ^ ((x ^ y) & -(x < y)); // max(x, y)
(define-fun impl0_max ((x (_ BitVec 32)) (y (_ BitVec 32))) (_ BitVec 32)
    (bvxor x (bvand (bvxor x y) (bvneg (ite (bvslt x y) (_ bv1 32) (_ bv0 32)))))
)

(push 1)
(echo "spec_max != impl0_max")
(assert (not (= (spec_max in_x in_y) (impl0_max in_x in_y))))
(check-sat)
(echo "")
(pop 1)

; If you know that INT_MIN <= x - y <= INT_MAX, then you can use the following, which are faster because (x - y) only needs to be evaluated once.
; r = y + ((x - y) & ((x - y) >> (sizeof(int) * CHAR_BIT - 1))); // min(x, y)
(define-fun impl1_min ((x (_ BitVec 32)) (y (_ BitVec 32))) (_ BitVec 32)
    (let (
        (x_minus_y (bvsub x y))
    )
    (bvadd y (bvand x_minus_y (bvlshr x_minus_y (_ bv31 32))))
    )
)

(define-const INT_MIN (_ BitVec 32) #x80000000)
(define-const INT_MAX (_ BitVec 32) #x7FFFFFFF)

(push 1)
(echo "spec_min != impl1_min, unconstrained: expect sat")
(assert (not (= (spec_min in_x in_y) (impl1_min in_x in_y))))
(check-sat)
(echo "in_x:")
(eval in_x)
(echo "in_y:")
(eval in_y)
(echo "spec_min:")
(eval (spec_min in_x in_y))
(echo "impl1_min:")
(eval (impl1_min in_x in_y))
(echo "")
(push 1)
(echo "spec_min != impl1_min, constrained with INT_MIN <= x - y <= INT_MAX: expect unsat")
(assert (and (bvsle ((_ zero_extend 1) INT_MIN) (bvsub ((_ zero_extend 1) in_x) ((_ zero_extend 1) in_y)))
             (bvsle (bvsub ((_ zero_extend 1) in_x) ((_ zero_extend 1) in_y)) ((_ zero_extend 1) INT_MAX))))
(check-sat)
(echo "")
(pop 2)

; Same thing but using arithmetic shift right instead of logical shift right
; r = y + ((x - y) & ((x - y) >> (sizeof(int) * CHAR_BIT - 1))); // min(x, y)
(define-fun impl2_min ((x (_ BitVec 32)) (y (_ BitVec 32))) (_ BitVec 32)
    (let (
        (x_minus_y (bvsub x y))
    )
    (bvadd y (bvand x_minus_y (bvashr x_minus_y (_ bv31 32))))
    )
)

(push 1)
(echo "spec_min != impl2_min, unconstrained: expect sat")
(assert (not (= (spec_min in_x in_y) (impl2_min in_x in_y))))
(check-sat)
(echo "in_x:")
(eval in_x)
(echo "in_y:")
(eval in_y)
(echo "spec_min:")
(eval (spec_min in_x in_y))
(echo "impl2_min:")
(eval (impl2_min in_x in_y))
(echo "")
(push 1)
(echo "spec_min != impl2_min, constrained with INT_MIN <= x - y <= INT_MAX: expect unsat")
(assert (and (bvsle ((_ zero_extend 1) INT_MIN) (bvsub ((_ zero_extend 1) in_x) ((_ zero_extend 1) in_y)))
             (bvsle (bvsub ((_ zero_extend 1) in_x) ((_ zero_extend 1) in_y)) ((_ zero_extend 1) INT_MAX))))
(check-sat)
(echo "")
(pop 2)

; r = x - ((x - y) & ((x - y) >> (sizeof(int) * CHAR_BIT - 1))); // max(x, y)
(define-fun impl1_max ((x (_ BitVec 32)) (y (_ BitVec 32))) (_ BitVec 32)
    (let (
        (x_minus_y (bvsub x y))
    )
    (bvsub x (bvand x_minus_y (bvlshr x_minus_y (_ bv31 32))))
    )
)

(push 1)
(echo "spec_max != impl1_max, unconstrained: expect sat")
(assert (not (= (spec_max in_x in_y) (impl1_max in_x in_y))))
(check-sat)
(echo "in_x:")
(eval in_x)
(echo "in_y:")
(eval in_y)
(echo "spec_max:")
(eval (spec_max in_x in_y))
(echo "impl1_max:")
(eval (impl1_max in_x in_y))
(echo "")
(push 1)
(echo "spec_max != impl1_max, constrained with INT_MIN <= x - y <= INT_MAX: expect unsat")
(assert (and (bvsle ((_ zero_extend 1) INT_MIN) (bvsub ((_ zero_extend 1) in_x) ((_ zero_extend 1) in_y)))
             (bvsle (bvsub ((_ zero_extend 1) in_x) ((_ zero_extend 1) in_y)) ((_ zero_extend 1) INT_MAX))))
(check-sat)
(echo "")
(pop 2)

; Same thing but using arithmetic shift right instead of logical shift right
; r = x - ((x - y) & ((x - y) >> (sizeof(int) * CHAR_BIT - 1))); // max(x, y)
(define-fun impl2_max ((x (_ BitVec 32)) (y (_ BitVec 32))) (_ BitVec 32)
    (let (
        (x_minus_y (bvsub x y))
    )
    (bvsub x (bvand x_minus_y (bvashr x_minus_y (_ bv31 32))))
    )
)

(push 1)
(echo "spec_max != impl2_max, unconstrained: expect sat")
(assert (not (= (spec_max in_x in_y) (impl2_max in_x in_y))))
(check-sat)
(echo "in_x:")
(eval in_x)
(echo "in_y:")
(eval in_y)
(echo "spec_max:")
(eval (spec_max in_x in_y))
(echo "impl2_max:")
(eval (impl2_max in_x in_y))
(echo "")
(push 1)
(echo "spec_max != impl2_max, constrained with INT_MIN <= x - y <= INT_MAX: expect unsat")
(assert (and (bvsle ((_ zero_extend 1) INT_MIN) (bvsub ((_ zero_extend 1) in_x) ((_ zero_extend 1) in_y)))
             (bvsle (bvsub ((_ zero_extend 1) in_x) ((_ zero_extend 1) in_y)) ((_ zero_extend 1) INT_MAX))))
(check-sat)
(echo "")
(pop 2)
